name: "MicroROS2 Firmware + Host Package"
version: 0.0.0
description: A template for creating MicroROS2 firmware with PlatformIO and a ROS 2 host package that builds and manages the firmware
license: "MIT"
icon: "ðŸ”Œ"
short_description: "Microcontroller + ROS 2 integration"
user_instruction: "Describe the firmware functionality for your microcontroller. Include details about sensors, actuators, ROS 2 topics/services/actions, connection type (serial/network), and hardware configuration. The C++ host package will automatically manage firmware lifecycle (version checking, upload, connection). Be specific about hardware pins, protocols, and data rates."
example_prompt: "Create MicroROS2 firmware for ESP32 to control a robotic gripper with servo motor on GPIO 18 and force sensor on GPIO 34. Firmware should publish force readings at 50Hz on /gripper/force topic and subscribe to gripper position commands on /gripper/position. Include a /gripper/calibrate service. Use WiFi transport to connect to host. The C++ host lifecycle node will handle firmware upload, version checking, and micro_ros_agent launch."
test_instruction: "Describe what should be tested in both the firmware and host package. Include hardware-in-the-loop tests, connection tests, firmware upload validation, and integration scenarios. Tests will only be generated if you provide this description."
test_example_prompt: "Create tests for host package connection manager, verify firmware version checking logic, test upload functionality with mock serial port, validate parameter parsing in launch files, and create integration tests for microROS agent communication. For firmware, test sensor reading accuracy and command processing."
ai_directive: |
  This template generates TWO components:
  1. MicroROS2 firmware (PlatformIO project) - implements ROS 2 communication via RCLC
  2. C++ lifecycle node (host package) - manages firmware lifecycle only (upload, version check, connection)

  CRITICAL ARCHITECTURE:
  - Host provides lifecycle management ONLY (not pub/sub) - all ROS 2 topics/services/actions are in firmware
  - Host MUST launch micro_ros_agent + lifecycle node together (agent bridges firmware to ROS 2)
  - C++ only (no Python), lifecycle node required, version.txt mandatory for version checking
  - Include Docker build system, PlatformIO debug config, launch files with parameters
  - Tests are OPTIONAL - only generate if user provides test description

  MICROROS2 FIRMWARE REQUIREMENTS:
  - Use PlatformIO as the build system (NOT Arduino IDE)
  - Create platformio.ini with appropriate board configuration
  - Use micro_ros_platformio library
  - Support multiple transport types: Serial (USB), UART, UDP, WiFi
  - Include proper microROS agent connection handling
  - Implement reconnection logic for robust operation
  - Use microROS publishers, subscribers, services as requested
  - Follow microcontroller resource constraints (memory, CPU)
  - Include error handling suitable for embedded systems
  - Support both polling and interrupt-driven patterns where appropriate
  - Include proper initialization sequence for microROS
  - Implement watchdog or health monitoring if applicable
  - Use appropriate RCLC (ROS Client Library for C) patterns
  - Include timing management (loop rates, executor spin)

  FIRMWARE ARCHITECTURE PATTERNS:
  - Main setup: Initialize hardware, microROS transport, node, publishers/subscribers
  - Main loop: Spin executor, process callbacks, handle reconnection
  - Use rclc_executor for callback management
  - Implement timer callbacks for periodic tasks
  - Support parameter handling via microROS parameters if needed
  - Include LED or status indicators for connection state
  - Implement graceful degradation if agent disconnects
  - Support firmware version reporting via topic or service

  PLATFORMIO CONFIG (platformio.ini):
  - Platform/board, micro_ros_platformio library, build flags for transport type
  - Upload/monitor settings, debug tool configuration, multiple environments if needed

  PLATFORMIO DEBUG (firmware/.vscode/launch.json):
  - PlatformIO debug config for hardware debuggers (stlink, jlink, cmsis-dap, esp-prog, etc.)
  - Upload-and-debug or debug-only modes

  HOST PACKAGE COMPONENTS:
  - C++ lifecycle node: configure (version check) â†’ activate (upload if needed, connect)
  - Connection manager: serial/network handling with auto-detect and reconnection
  - Firmware uploader: reads version.txt, compares with device, flashes if mismatch
  - Launch files: always include micro_ros_agent + host node with configurable parameters
  - Docker build system: cross-platform firmware compilation
  - Multi-instance support: multiple devices with namespacing (if enabled)

  DOCKER BUILD:
  - Dockerfile with PlatformIO, mount firmware source, output to resource/firmware/
  - build_firmware.sh/.cmd scripts for cross-platform compilation

  FIRMWARE RESOURCES:
  - Store in resource/firmware/: firmware.bin, firmware.elf, version.txt (required)
  - Checksum verification, support multiple variants if needed

  CONNECTION & UPLOAD:
  - Serial: auto-detect VID/PID or specify port, hot-plug detection
  - Network: UDP/TCP with IP/port, connection retry with backoff
  - Upload: detect device, compare versions, flash if mismatch (auto-upload default: off)
  - Use platformio/esptool/stm32flash/teensy_loader_cli, provide progress feedback

  LAUNCH FILES:
  - Main: micro_ros_agent + host lifecycle node (both required)
  - Parameters: connection_type, serial_port, VID/PID, IP/port, auto_upload, namespace
  - Examples: serial, network, multi-instance variants

  VERSION MANAGEMENT:
  - Host reads resource/firmware/version.txt (semantic versioning: "1.0.0")
  - Queries device version, compares, triggers upload if mismatch (respects auto_upload flag)
  - Firmware embeds version string and reports via service/topic

  HOST IMPLEMENTATION (C++):
  - rclcpp_lifecycle node with states: configure (version check) â†’ activate (upload, connect)
  - rclcpp_components for composable architecture
  - Connection manager, firmware uploader, transport abstraction classes
  - Async operations, comprehensive logging, modern C++17+ patterns
  - Headers: microros_lifecycle_manager.hpp, connection_manager.hpp, firmware_uploader.hpp

  DEBUGGING & DEFAULTS:
  - PlatformIO debug config in firmware/.vscode/launch.json (ST-Link, J-Link, etc.)
  - Auto-upload DISABLED by default (prevents debug conflicts, enable via launch parameter)
  - Firmware debugs independently from host - document hardware debugger setup

  MULTI-INSTANCE (if enabled):
  - Unique identification via VID/PID/serial number, namespacing per instance
  - Multi-instance launch file with device discovery

  QUALITY ASSURANCE:
  - Include comprehensive documentation in README.md
  - Document hardware requirements and setup
  - Include wiring diagrams if applicable
  - Provide troubleshooting guide
  - Include example usage and configuration
  - Document debugging workflow
  - Add testing instructions (hardware-in-loop, simulation)
  - Include CI/CD configuration for automated firmware builds
  - Provide development environment setup instructions

  PACKAGE STRUCTURE:
  The generated package should have this structure (C++ ONLY):

  ```
  {{package_name}}/
  â”œâ”€â”€ CMakeLists.txt                # C++ build configuration
  â”œâ”€â”€ package.xml
  â”œâ”€â”€ README.md
  â”œâ”€â”€ LICENSE
  â”œâ”€â”€ CONTRIBUTING.md
  â”œâ”€â”€ .gitignore
  â”œâ”€â”€ Dockerfile                    # Firmware build environment
  â”œâ”€â”€ .dockerignore
  â”œâ”€â”€ build_firmware.sh             # Firmware build script (Linux/macOS)
  â”œâ”€â”€ build_firmware.cmd            # Firmware build script (Windows)
  â”œâ”€â”€ firmware/                     # MicroROS2 firmware source
  â”‚   â”œâ”€â”€ platformio.ini
  â”‚   â”œâ”€â”€ src/
  â”‚   â”‚   â””â”€â”€ main.cpp              # Main firmware code with RCLC node
  â”‚   â”œâ”€â”€ include/
  â”‚   â”‚   â””â”€â”€ {{package_name}}.h
  â”‚   â”œâ”€â”€ lib/                      # Custom libraries if needed
  â”‚   â””â”€â”€ .vscode/
  â”‚       â””â”€â”€ launch.json           # PlatformIO debug configuration
  â”œâ”€â”€ resource/
  â”‚   â”œâ”€â”€ {{package_name}}          # ament resource index
  â”‚   â””â”€â”€ firmware/
  â”‚       â”œâ”€â”€ firmware.bin          # Compiled firmware binary. During AI generation, fill with just the word `placeholder`
  â”‚       â”œâ”€â”€ firmware.elf          # Debug symbols. During AI generation, fill with just the word `placeholder`
  â”‚       â””â”€â”€ version.txt           # Firmware version metadata (MANDATORY for version checking)
  â”œâ”€â”€ config/
  â”‚   â”œâ”€â”€ connection_params.yaml    # Connection configuration
  â”‚   â””â”€â”€ firmware_params.yaml      # Firmware parameters
  â”œâ”€â”€ launch/
  â”‚   â”œâ”€â”€ {{package_name}}.launch.py         # Main launch file (MUST launch agent + host)
  â”‚   â”œâ”€â”€ {{package_name}}_serial.launch.py  # Serial connection example
  â”‚   â”œâ”€â”€ {{package_name}}_network.launch.py # Network connection example
  â”‚   â””â”€â”€ {{package_name}}_multi.launch.py   # Multi-instance example
  â”œâ”€â”€ include/{{package_name}}/     # C++ host package headers
  â”‚   â”œâ”€â”€ microros_lifecycle_manager.hpp     # Lifecycle node for firmware management
  â”‚   â”œâ”€â”€ connection_manager.hpp             # Connection handling
  â”‚   â”œâ”€â”€ firmware_uploader.hpp              # Firmware upload logic
  â”‚   â””â”€â”€ visibility_control.h
  â”œâ”€â”€ src/                          # C++ host package source
  â”‚   â”œâ”€â”€ microros_lifecycle_manager.cpp     # Lifecycle node (version check, upload, connect)
  â”‚   â”œâ”€â”€ connection_manager.cpp             # Serial/network connection
  â”‚   â”œâ”€â”€ firmware_uploader.cpp              # Firmware flash functionality
  â”‚   â””â”€â”€ component.cpp                      # rclcpp_components registration
  â”œâ”€â”€ test/                         # OPTIONAL - only generate if test description is provided
  â”‚   â”œâ”€â”€ test_connection.cpp       # Connection tests (OPTIONAL)
  â”‚   â””â”€â”€ test_firmware_upload.cpp  # Upload tests (OPTIONAL)
  â””â”€â”€ docs/
      â”œâ”€â”€ hardware_setup.md         # Hardware setup guide
      â”œâ”€â”€ debugging.md              # Debugging guide
      â””â”€â”€ troubleshooting.md        # Troubleshooting guide
  ```

  NOTE: test/ directory is OPTIONAL - only if user provides test description

  TRANSPORT TYPES:
  - Serial/USB: Configure baud rate, VID/PID filtering, agent: `micro_ros_agent serial --dev /dev/ttyUSB0 -b 115200`
  - Network: WiFi/Ethernet with UDP/TCP, WiFi credentials if needed, agent: `micro_ros_agent udp4 --port 8888`

  PLATFORMS: ESP32/ESP8266 (WiFi), STM32 (CAN/UART), Teensy (ARM), Arduino, RPi Pico

  AGENT: Host launches micro_ros_agent (bridges DDS-XRCE â†” DDS), configurable namespace/logging

  ERROR HANDLING & SECURITY:
  - Firmware: resource-aware error handling, graceful degradation
  - Host: detailed error handling, recovery mechanisms, comprehensive logging
  - Checksum verification for firmware binaries, validate connection parameters
  - Health monitoring for connection status

  EXAMPLE USAGE:
  ```bash
  # Build firmware using Docker
  ./build_firmware.sh

  # Launch host lifecycle node + micro_ros_agent with serial connection
  ros2 launch {{package_name}} {{package_name}}.launch.py connection_type:=serial

  # Launch with specific serial port and enable auto-upload
  ros2 launch {{package_name}} {{package_name}}.launch.py connection_type:=serial serial_port:=/dev/ttyUSB0 auto_upload:=true

  # Launch with network connection (WiFi/Ethernet)
  ros2 launch {{package_name}} {{package_name}}.launch.py connection_type:=network network_ip:=192.168.1.100 network_port:=8888

  # Interact with firmware ROS 2 topics (firmware appears as native ROS 2 node via agent)
  ros2 topic list
  ros2 topic echo /your_firmware_topic
  ros2 service call /your_firmware_service

  # Check host lifecycle state (firmware management)
  ros2 lifecycle nodes
  ros2 lifecycle get /{{package_name}}_lifecycle_manager

  # Debug firmware with PlatformIO
  # 1. Connect hardware debugger (ST-Link, J-Link, etc.)
  # 2. Disable auto_upload in launch file to prevent upload conflicts
  # 3. Open VS Code, go to Run and Debug (Ctrl+Shift+D)
  # 4. Select "PIO Debug ({{board_name}})"
  # 5. Press F5 to start debugging firmware directly
  ```

  OPTIONAL ENHANCEMENTS (if requested):
  - Parameter server for dynamic config, OTA updates, monitoring dashboard
  - Simulation support, performance metrics, power management

options:
  - variable: "package_name"
    name: "Package Name"
    type: "string"
    description: "Name of the ROS 2 package (and prefix for firmware)"
    default: "my_microros_package"
    

  - variable: "microcontroller_platform"
    name: "Microcontroller Platform"
    type: "select"
    description: "Target microcontroller platform"
    choices:
      - value: "esp32"
        label: "ESP32 (WiFi, Bluetooth, dual-core)"
      - value: "esp8266"
        label: "ESP8266 (WiFi, single-core)"
      - value: "stm32"
        label: "STM32 (Various families)"
      - value: "teensy"
        label: "Teensy (High-performance ARM)"
      - value: "arduino"
        label: "Arduino (Various boards)"
      - value: "rpi_pico"
        label: "Raspberry Pi Pico"
    default: "esp32"
    
  - variable: "board_name"
    name: "Board Name"
    type: "string"
    description: "Specific board identifier for PlatformIO (e.g., esp32dev, nucleo_f446re, teensy41)"
    default: "esp32dev"
    
  - variable: "transport_type"
    name: "Primary Transport Type"
    type: "select"
    description: "Communication transport between firmware and host"
    choices:
      - value: "serial"
        label: "Serial/USB (most common)"
      - value: "udp"
        label: "UDP over WiFi/Ethernet"
      - value: "tcp"
        label: "TCP over WiFi/Ethernet"
    default: "serial"
    
  - variable: "include_wifi"
    name: "Include WiFi Configuration"
    type: "boolean"
    description: "Include WiFi setup code (for ESP32/ESP8266 with network transport)"
    default: false
    condition: "transport_type == 'udp' || transport_type == 'tcp'"
    
  - variable: "default_baud_rate"
    name: "Serial Baud Rate"
    type: "string"
    description: "Default baud rate for serial communication"
    default: "115200"
    condition: "transport_type == 'serial'"
    
  - variable: "debug_tool"
    name: "Debug Tool"
    type: "select"
    description: "Hardware debugger for PlatformIO debugging"
    choices:
      - value: "stlink"
        label: "ST-Link (STM32)"
      - value: "jlink"
        label: "J-Link (Universal)"
      - value: "cmsis-dap"
        label: "CMSIS-DAP"
      - value: "esp-prog"
        label: "ESP-Prog (ESP32)"
      - value: "picoprobe"
        label: "Picoprobe (Raspberry Pi Pico)"
    default: "stlink"
    
  - variable: "include_publisher"
    name: "Include Publisher Example"
    type: "boolean"
    description: "Include example publisher in firmware"
    default: true
    
  - variable: "include_subscriber"
    name: "Include Subscriber Example"
    type: "boolean"
    description: "Include example subscriber in firmware"
    default: true
    
  - variable: "include_service"
    name: "Include Service Example"
    type: "boolean"
    description: "Include example service in firmware"
    default: false
    
  - variable: "include_version_service"
    name: "Include Version Query Service"
    type: "boolean"
    description: "Include service for querying firmware version"
    default: true
    
  - variable: "auto_upload_default"
    name: "Auto-Upload Default"
    type: "boolean"
    description: "Enable automatic firmware upload by default (NOT recommended for development)"
    default: false
    
  - variable: "include_multi_instance"
    name: "Multi-Instance Support"
    type: "boolean"
    description: "Include support for multiple microcontroller instances"
    default: false
    
  - variable: "include_diagnostics"
    name: "Include Diagnostics"
    type: "boolean"
    description: "Include diagnostic publishers for monitoring health"
    default: true
    
  - variable: "include_lifecycle"
    name: "Use Lifecycle Node"
    type: "boolean"
    description: "Use lifecycle node for host package (always recommended)"
    default: true
    
  - variable: "support_humble"
    name: "Support ROS 2 Humble"
    type: "boolean"
    description: "Include compatibility support for ROS 2 Humble (uses legacy CMake patterns)"
    default: true

file_mapping: []
