name: "MicroROS2 Firmware + Host Package"
version: 0.0.0
description: A template for creating MicroROS2 firmware with PlatformIO and a ROS 2 host package that builds and manages the firmware
license: "MIT"
icon: "ðŸ”Œ"
short_description: "Microcontroller + ROS 2 integration"
user_instruction: "Describe the firmware functionality for your microcontroller. Include details about sensors, actuators, ROS 2 topics/services/actions, connection type (serial/network), and hardware configuration. The C++ host package will automatically manage firmware lifecycle (version checking, upload, connection). Be specific about hardware pins, protocols, and data rates."
example_prompt: "Create MicroROS2 firmware for ESP32 to control a robotic gripper with servo motor on GPIO 18 and force sensor on GPIO 34. Firmware should publish force readings at 50Hz on /gripper/force topic and subscribe to gripper position commands on /gripper/position. Include a /gripper/calibrate service. Use WiFi transport to connect to host. The C++ host lifecycle node will handle firmware upload, version checking, and micro_ros_agent launch."
test_instruction: "Describe what should be tested in both the firmware and host package. Include hardware-in-the-loop tests, connection tests, firmware upload validation, and integration scenarios. Tests will only be generated if you provide this description."
test_example_prompt: "Create tests for host package connection manager, verify firmware version checking logic, test upload functionality with mock serial port, validate parameter parsing in launch files, and create integration tests for microROS agent communication. For firmware, test sensor reading accuracy and command processing."
ai_directive: |
  This is a MicroROS2 template that generates BOTH firmware for a microcontroller AND a C++ ROS 2 host package.
  The host package ONLY manages firmware lifecycle - it does NOT replicate firmware's pub/sub interface.

  HIGH PRIORITY REQUIREMENTS:
  - Generate TWO distinct components:
    1. MicroROS2 firmware (PlatformIO project for microcontroller)
    2. C++ ROS 2 lifecycle node that manages firmware (NO Python option)
  - The host package MUST include Docker-based firmware build system
  - The compiled firmware binary MUST be included as a package resource
  - Include launch files that MUST launch both micro_ros_agent + host lifecycle node
  - Support firmware version checking via resource/firmware/version.txt (mandatory)
  - Include PlatformIO debug configuration for standalone firmware debugging
  - Follow all ROS 2 C++ best practices for the host package
  - Follow MicroROS best practices for the firmware
  - IMPORTANT: Do NOT generate test files unless explicitly requested by the user in a separate test description. The test/ directory in the package structure is OPTIONAL.

  MICROROS2 FIRMWARE REQUIREMENTS:
  - Use PlatformIO as the build system (NOT Arduino IDE)
  - Create platformio.ini with appropriate board configuration
  - Use micro_ros_platformio library
  - Support multiple transport types: Serial (USB), UART, UDP, WiFi
  - Include proper microROS agent connection handling
  - Implement reconnection logic for robust operation
  - Use microROS publishers, subscribers, services as requested
  - Follow microcontroller resource constraints (memory, CPU)
  - Include error handling suitable for embedded systems
  - Support both polling and interrupt-driven patterns where appropriate
  - Include proper initialization sequence for microROS
  - Implement watchdog or health monitoring if applicable
  - Use appropriate RCLC (ROS Client Library for C) patterns
  - Include timing management (loop rates, executor spin)

  FIRMWARE ARCHITECTURE PATTERNS:
  - Main setup: Initialize hardware, microROS transport, node, publishers/subscribers
  - Main loop: Spin executor, process callbacks, handle reconnection
  - Use rclc_executor for callback management
  - Implement timer callbacks for periodic tasks
  - Support parameter handling via microROS parameters if needed
  - Include LED or status indicators for connection state
  - Implement graceful degradation if agent disconnects
  - Support firmware version reporting via topic or service

  PLATFORMIO CONFIGURATION:
  - Include appropriate platform (e.g., espressif32, ststm32, teensy, etc.)
  - Specify board model (e.g., esp32dev, nucleo_f446re, teensy41)
  - Add micro_ros_platformio library dependency
  - Configure build flags for microROS (transport type, memory settings)
  - Include upload settings (upload_port, upload_speed)
  - Add debug configuration (debug_tool, debug_port, debug_speed)
  - Support multiple build environments (debug, release, different boards)
  - Include monitor settings (monitor_speed, monitor_port)
  - Add custom scripts for pre/post build if needed
  - Configure microROS transport via build flags

  Example platformio.ini structure:
  ```ini
  [env:{{board_name}}]
  platform = {{platform}}
  board = {{board}}
  framework = arduino
  lib_deps = 
      https://github.com/micro-ROS/micro_ros_platformio
  build_flags = 
      -DMICRO_ROS_TRANSPORT_{{transport_type}}
      -DRCL_LOGGING_ENABLED
  monitor_speed = 115200
  upload_speed = 921600
  debug_tool = {{debug_tool}}
  debug_init_break = tbreak setup
  ```

  PLATFORMIO DEBUG CONFIGURATION:
  - Include .vscode/launch.json with PlatformIO debug configurations
  - Support common debug tools: stlink, jlink, cmsis-dap, esp-prog, etc.
  - Configure debug breakpoints and initialization
  - Include separate configurations for different boards if multiple environments exist
  - Support both upload-and-debug and debug-only modes
  - Include GDB server configuration
  - Add debugging symbols and optimization flags for debug builds
  - Example launch.json with PIO Debug configuration

  Example .vscode/launch.json:
  ```json
  {
    "version": "0.2.0",
    "configurations": [
      {
        "type": "platformio-debug",
        "request": "launch",
        "name": "PIO Debug ({{board_name}})",
        "executable": ".pio/build/{{board_name}}/firmware.elf",
        "projectEnvName": "{{board_name}}",
        "toolchainBinDir": "",
        "internalConsoleOptions": "openOnSessionStart",
        "preLaunchTask": {
          "type": "PlatformIO",
          "task": "Pre-Debug"
        }
      }
    ]
  }
  ```

  ROS 2 HOST PACKAGE REQUIREMENTS:
  - Acts as LIFECYCLE MANAGER ONLY for the microcontroller firmware
  - MUST use micro_ros_agent (do NOT implement agent functionality in host)
  - Manages firmware lifecycle: version check (via version.txt), upload, connection management
  - CRITICAL: Does NOT provide ROS 2 pub/sub/service/action interfaces
  - All ROS 2 communication happens in firmware through micro_ros_agent bridge
  - Host only provides: firmware upload service, version checking, connection status
  - Includes Docker-based firmware build system
  - Stores compiled firmware as a package resource with version.txt
  - Includes configuration files for connection parameters
  - Provides launch files that MUST launch micro_ros_agent + host lifecycle node
  - Implements health monitoring for connection status only
  - Supports multiple microcontroller instances (multi-robot scenarios)
  - MUST be C++ only (no Python option)

  DOCKER-BASED FIRMWARE BUILD:
  - Create Dockerfile for firmware compilation environment
  - Use official PlatformIO Docker image or build custom image based on the user's specification of platform
  - Install necessary dependencies (PlatformIO, toolchains)
  - Mount firmware source as volume during build
  - Copy compiled binary to package resource directory
  - Include build script that can be run locally or in CI/CD
  - Support cross-platform builds (Linux, Windows, macOS via Docker)
  - Cache dependencies for faster subsequent builds
  - Include .dockerignore to exclude unnecessary files

  Example Dockerfile:
  ```dockerfile
  FROM python:3.11-slim
  RUN pip install platformio
  WORKDIR /firmware
  COPY firmware/ /firmware/
  RUN pio run -e {{board_name}}
  ```

  Example build script (build_firmware.sh or build_firmware.cmd):
  ```bash
  #!/bin/bash
  docker build -t {{package_name}}_firmware_builder .
  docker run --rm -v $(pwd)/firmware:/firmware -v $(pwd)/resource/firmware:/output {{package_name}}_firmware_builder cp .pio/build/{{board_name}}/firmware.bin /output/
  ```

  FIRMWARE RESOURCE MANAGEMENT:
  - Store firmware binary in resource/firmware/ directory
  - MUST include resource/firmware/version.txt with firmware version (e.g., "1.0.0")
  - Host C++ node MUST read version.txt file to determine expected firmware version
  - Implement firmware hash checking for integrity
  - Support multiple firmware variants if needed (different boards, features)
  - Include metadata file with firmware information (build date, git commit, features)

  CONNECTION MANAGEMENT IN HOST PACKAGE:
  - Support serial connection: auto-detect or specify VID/PID
  - Support network connection: UDP or TCP with configurable IP/port
  - Implement connection retry with exponential backoff
  - Provide connection status monitoring
  - Support hot-plug detection for USB devices
  - Implement graceful handling of disconnection
  - Include connection state publishing for monitoring
  - Support multiple simultaneous connections if needed

  FIRMWARE UPLOAD FUNCTIONALITY:
  - Detect connected microcontroller via VID/PID or serial port
  - Read firmware version from microcontroller (if available)
  - Compare with packaged firmware version
  - Upload firmware if versions don't match or forced
  - Support configurable auto-upload behavior (default: disabled)
  - Use appropriate upload tool: platformio, esptool, stm32flash, teensy_loader_cli
  - Provide upload progress feedback
  - Verify successful upload before attempting connection
  - Support DFU mode entry if needed

  LAUNCH FILE CONFIGURATION:
  - MUST include micro_ros_agent node - this is REQUIRED, not optional
  - Include parameterized launch file for connection configuration
  - Support command-line arguments and launch parameters
  - Allow runtime specification of: serial port, VID/PID, IP address, port
  - Include namespace support for multi-robot scenarios
  - Launch host lifecycle node + micro_ros_agent together (both required)
  - Include remapping capabilities
  - Provide examples for different connection types
  - Support conditional parameters but NOT conditional agent (agent always launches)

  Example launch file structure:
  ```python
  def generate_launch_description():
      # Declare arguments
      connection_type_arg = DeclareLaunchArgument('connection_type', default_value='serial')
      serial_port_arg = DeclareLaunchArgument('serial_port', default_value='/dev/ttyUSB0')
      network_ip_arg = DeclareLaunchArgument('network_ip', default_value='192.168.1.100')
      auto_upload_arg = DeclareLaunchArgument('auto_upload', default_value='false')
      
      # ALWAYS include micro_ros_agent node (required for firmware bridge)
      # ALWAYS include host lifecycle node (firmware management)
      # Agent and host work together - both are mandatory
  ```

  FIRMWARE VERSION CHECKING:
  - Host C++ node MUST read resource/firmware/version.txt file for expected version
  - Query actual version from microcontroller via service or topic
  - Compare version.txt version with actual firmware version
  - Trigger upload if versions don't match (unless auto_upload disabled)
  - Log version information (expected vs actual)
  - Provide version mismatch warnings
  - MANDATORY format: semantic versioning (major.minor.patch) e.g., "1.0.0"
  - This is the ONLY version checking mechanism - version.txt is authoritative source

  HOST PACKAGE ARCHITECTURE (C++ ONLY):
  - Use lifecycle node for firmware lifecycle management (REQUIRED)
  - Lifecycle states: configure (check version), activate (upload if needed, connect)
  - Include rclcpp_lifecycle and rclcpp_components registration
  - Provide connection manager class (serial/network handling)
  - Implement firmware uploader class (version check, flash)
  - Include transport abstraction layer
  - Support asynchronous operations for non-blocking behavior
  - Include comprehensive logging and diagnostics
  - Follow modern C++17+ patterns
  - CRITICAL: Host node provides lifecycle services ONLY
  - Host node does NOT implement publishers, subscribers, services, or actions
  - All ROS 2 communication happens in firmware via micro_ros_agent bridge
  - Host only manages: connection, version checking, firmware upload
  - NO Python host package option - C++ is mandatory

  DEBUGGING WORKFLOW:
  - User can debug firmware independently using PlatformIO debugger
  - Launch.json includes PlatformIO debug configuration
  - Debug workflow: attach hardware debugger (ST-Link, J-Link, etc.)
  - Set breakpoints in firmware code
  - Launch PIO Debug from VS Code
  - Firmware debugging is separate from host package
  - Host package should NOT attempt upload during active debug session
  - Document debugging prerequisites (hardware debugger, connections)

  DEFAULT BEHAVIOR FOR PRODUCTION:
  - Auto-upload should be DISABLED by default
  - Prevents interference with debugging sessions
  - User must explicitly enable auto-upload via launch parameter
  - Suitable for bringup and development workflows
  - Prevents accidental firmware overwrites during testing

  MULTI-INSTANCE SUPPORT:
  - Support multiple microcontrollers connected simultaneously
  - Use unique identifiers (serial number, VID/PID combinations)
  - Include namespace or prefix for each instance
  - Provide launch file that can spawn multiple instances
  - Support different configurations per instance
  - Include mechanism to discover connected devices

  QUALITY ASSURANCE:
  - Include comprehensive documentation in README.md
  - Document hardware requirements and setup
  - Include wiring diagrams if applicable
  - Provide troubleshooting guide
  - Include example usage and configuration
  - Document debugging workflow
  - Add testing instructions (hardware-in-loop, simulation)
  - Include CI/CD configuration for automated firmware builds
  - Provide development environment setup instructions

  PACKAGE STRUCTURE:
  The generated package should have this structure (C++ ONLY):

  ```
  {{package_name}}/
  â”œâ”€â”€ CMakeLists.txt                # C++ build configuration
  â”œâ”€â”€ package.xml
  â”œâ”€â”€ README.md
  â”œâ”€â”€ LICENSE
  â”œâ”€â”€ CONTRIBUTING.md
  â”œâ”€â”€ .gitignore
  â”œâ”€â”€ Dockerfile                    # Firmware build environment
  â”œâ”€â”€ .dockerignore
  â”œâ”€â”€ build_firmware.sh             # Firmware build script (Linux/macOS)
  â”œâ”€â”€ build_firmware.cmd            # Firmware build script (Windows)
  â”œâ”€â”€ firmware/                     # MicroROS2 firmware source
  â”‚   â”œâ”€â”€ platformio.ini
  â”‚   â”œâ”€â”€ src/
  â”‚   â”‚   â””â”€â”€ main.cpp              # Main firmware code with RCLC node
  â”‚   â”œâ”€â”€ include/
  â”‚   â”‚   â””â”€â”€ {{package_name}}.h
  â”‚   â”œâ”€â”€ lib/                      # Custom libraries if needed
  â”‚   â””â”€â”€ .vscode/
  â”‚       â””â”€â”€ launch.json           # PlatformIO debug configuration
  â”œâ”€â”€ resource/
  â”‚   â”œâ”€â”€ {{package_name}}          # ament resource index
  â”‚   â””â”€â”€ firmware/
  â”‚       â”œâ”€â”€ firmware.bin          # Compiled firmware binary. During AI generation, fill with just the word `placeholder`
  â”‚       â”œâ”€â”€ firmware.elf          # Debug symbols. During AI generation, fill with just the word `placeholder`
  â”‚       â””â”€â”€ version.txt           # Firmware version metadata (MANDATORY for version checking)
  â”œâ”€â”€ config/
  â”‚   â”œâ”€â”€ connection_params.yaml    # Connection configuration
  â”‚   â””â”€â”€ firmware_params.yaml      # Firmware parameters
  â”œâ”€â”€ launch/
  â”‚   â”œâ”€â”€ {{package_name}}.launch.py         # Main launch file (MUST launch agent + host)
  â”‚   â”œâ”€â”€ {{package_name}}_serial.launch.py  # Serial connection example
  â”‚   â”œâ”€â”€ {{package_name}}_network.launch.py # Network connection example
  â”‚   â””â”€â”€ {{package_name}}_multi.launch.py   # Multi-instance example
  â”œâ”€â”€ include/{{package_name}}/     # C++ host package headers
  â”‚   â”œâ”€â”€ microros_lifecycle_manager.hpp     # Lifecycle node for firmware management
  â”‚   â”œâ”€â”€ connection_manager.hpp             # Connection handling
  â”‚   â”œâ”€â”€ firmware_uploader.hpp              # Firmware upload logic
  â”‚   â””â”€â”€ visibility_control.h
  â”œâ”€â”€ src/                          # C++ host package source
  â”‚   â”œâ”€â”€ microros_lifecycle_manager.cpp     # Lifecycle node (version check, upload, connect)
  â”‚   â”œâ”€â”€ connection_manager.cpp             # Serial/network connection
  â”‚   â”œâ”€â”€ firmware_uploader.cpp              # Firmware flash functionality
  â”‚   â””â”€â”€ component.cpp                      # rclcpp_components registration
  â”œâ”€â”€ test/                         # OPTIONAL - only generate if test description is provided
  â”‚   â”œâ”€â”€ test_connection.cpp       # Connection tests (OPTIONAL)
  â”‚   â””â”€â”€ test_firmware_upload.cpp  # Upload tests (OPTIONAL)
  â””â”€â”€ docs/
      â”œâ”€â”€ hardware_setup.md         # Hardware setup guide
      â”œâ”€â”€ debugging.md              # Debugging guide
      â””â”€â”€ troubleshooting.md        # Troubleshooting guide
  ```

  CRITICAL NOTES:
  - NO scripts/ directory - firmware manipulation is handled by lifecycle node
  - NO Python host package - C++ only
  - Host node is a lifecycle node that manages firmware lifecycle (NOT pub/sub interface)
  - All launch files MUST include micro_ros_agent + host lifecycle node
  - version.txt is mandatory for version checking
  - test/ directory is OPTIONAL - only generate if user provides test description

  TRANSPORT-SPECIFIC IMPLEMENTATIONS:

  Serial/USB Transport (most common):
  - Use Serial or UART for microROS transport
  - Configure baud rate (typically 115200 or higher)
  - Handle serial port enumeration and auto-detection
  - Support VID/PID filtering for device identification
  - Implement serial reconnection logic
  - Include buffer management for serial communication
  - micro_ros_agent: `micro_ros_agent serial --dev /dev/ttyUSB0 -b 115200`

  Network Transport (WiFi/Ethernet):
  - Use UDP or TCP for microROS transport
  - Configure microcontroller as client or server
  - Include WiFi credentials configuration (if WiFi)
  - Implement IP address configuration or DHCP
  - Support mDNS for device discovery
  - Include network error handling and retry logic
  - micro_ros_agent: `micro_ros_agent udp4 --port 8888`

  SUPPORTED PLATFORMS (common examples):
  - ESP32 (espressif32 platform): WiFi, Bluetooth, dual-core
  - ESP8266 (espressif8266 platform): WiFi, single-core
  - STM32 (ststm32 platform): Various families, CAN, UART
  - Teensy (teensy platform): High-performance ARM Cortex-M
  - Arduino boards (atmelavr, atmelsam platforms)
  - Raspberry Pi Pico (raspberrypi platform)

  MICROROS AGENT INTEGRATION:
  - Host package should launch micro_ros_agent
  - Agent provides bridge between microROS (DDS-XRCE) and ROS 2 (DDS)
  - Support agent configuration via parameters
  - Include agent namespace configuration
  - Monitor agent health and restart if needed
  - Support agent logging configuration

  SECURITY CONSIDERATIONS:
  - Validate firmware binaries before upload
  - Implement checksum verification
  - Support secure boot if hardware supports it
  - Include firmware signing if required
  - Validate connection parameters
  - Implement rate limiting for uploads
  - Log all firmware operations for audit

  ERROR HANDLING:
  - Comprehensive error handling in firmware (limited resources)
  - Detailed error handling in host package
  - Include recovery mechanisms
  - Provide meaningful error messages
  - Log errors for debugging
  - Support different error reporting mechanisms
  - Include health monitoring and diagnostics topics

  DOCUMENTATION REQUIREMENTS:
  - README.md: Overview, features, quick start, usage examples
  - Hardware setup guide: Wiring, connections, prerequisites
  - Debugging guide: PlatformIO debug setup, common issues
  - Troubleshooting guide: Common problems and solutions
  - API documentation: Host package interfaces
  - Firmware documentation: Code structure, customization
  - Build instructions: Docker builds, local builds
  - Deployment guide: Production deployment considerations

  EXAMPLE USAGE PATTERNS:
  ```bash
  # Build firmware using Docker
  ./build_firmware.sh

  # Launch host lifecycle node + micro_ros_agent with serial connection
  ros2 launch {{package_name}} {{package_name}}.launch.py connection_type:=serial

  # Launch with specific serial port and enable auto-upload
  ros2 launch {{package_name}} {{package_name}}.launch.py connection_type:=serial serial_port:=/dev/ttyUSB0 auto_upload:=true

  # Launch with network connection (WiFi/Ethernet)
  ros2 launch {{package_name}} {{package_name}}.launch.py connection_type:=network network_ip:=192.168.1.100 network_port:=8888

  # Interact with firmware ROS 2 topics (firmware appears as native ROS 2 node via agent)
  ros2 topic list
  ros2 topic echo /your_firmware_topic
  ros2 service call /your_firmware_service

  # Check host lifecycle state (firmware management)
  ros2 lifecycle nodes
  ros2 lifecycle get /{{package_name}}_lifecycle_manager

  # Debug firmware with PlatformIO
  # 1. Connect hardware debugger (ST-Link, J-Link, etc.)
  # 2. Disable auto_upload in launch file to prevent upload conflicts
  # 3. Open VS Code, go to Run and Debug (Ctrl+Shift+D)
  # 4. Select "PIO Debug ({{board_name}})"
  # 5. Press F5 to start debugging firmware directly
  ```

  ADDITIONAL FEATURES TO CONSIDER:
  - Parameter server integration for dynamic configuration
  - Firmware over-the-air (OTA) updates
  - Configuration file generation for microcontroller
  - Simulation support (Gazebo, mock microcontroller)
  - Monitoring dashboard (rqt plugin)
  - Performance metrics collection
  - Power management features
  - Bootloader support for field updates
  - Factory reset functionality

options:
  - variable: "package_name"
    name: "Package Name"
    type: "string"
    description: "Name of the ROS 2 package (and prefix for firmware)"
    default: "my_microros_package"
    

  - variable: "microcontroller_platform"
    name: "Microcontroller Platform"
    type: "select"
    description: "Target microcontroller platform"
    choices:
      - value: "esp32"
        label: "ESP32 (WiFi, Bluetooth, dual-core)"
      - value: "esp8266"
        label: "ESP8266 (WiFi, single-core)"
      - value: "stm32"
        label: "STM32 (Various families)"
      - value: "teensy"
        label: "Teensy (High-performance ARM)"
      - value: "arduino"
        label: "Arduino (Various boards)"
      - value: "rpi_pico"
        label: "Raspberry Pi Pico"
    default: "esp32"
    
  - variable: "board_name"
    name: "Board Name"
    type: "string"
    description: "Specific board identifier for PlatformIO (e.g., esp32dev, nucleo_f446re, teensy41)"
    default: "esp32dev"
    
  - variable: "transport_type"
    name: "Primary Transport Type"
    type: "select"
    description: "Communication transport between firmware and host"
    choices:
      - value: "serial"
        label: "Serial/USB (most common)"
      - value: "udp"
        label: "UDP over WiFi/Ethernet"
      - value: "tcp"
        label: "TCP over WiFi/Ethernet"
    default: "serial"
    
  - variable: "include_wifi"
    name: "Include WiFi Configuration"
    type: "boolean"
    description: "Include WiFi setup code (for ESP32/ESP8266 with network transport)"
    default: false
    condition: "transport_type == 'udp' || transport_type == 'tcp'"
    
  - variable: "default_baud_rate"
    name: "Serial Baud Rate"
    type: "string"
    description: "Default baud rate for serial communication"
    default: "115200"
    condition: "transport_type == 'serial'"
    
  - variable: "debug_tool"
    name: "Debug Tool"
    type: "select"
    description: "Hardware debugger for PlatformIO debugging"
    choices:
      - value: "stlink"
        label: "ST-Link (STM32)"
      - value: "jlink"
        label: "J-Link (Universal)"
      - value: "cmsis-dap"
        label: "CMSIS-DAP"
      - value: "esp-prog"
        label: "ESP-Prog (ESP32)"
      - value: "picoprobe"
        label: "Picoprobe (Raspberry Pi Pico)"
    default: "stlink"
    
  - variable: "include_publisher"
    name: "Include Publisher Example"
    type: "boolean"
    description: "Include example publisher in firmware"
    default: true
    
  - variable: "include_subscriber"
    name: "Include Subscriber Example"
    type: "boolean"
    description: "Include example subscriber in firmware"
    default: true
    
  - variable: "include_service"
    name: "Include Service Example"
    type: "boolean"
    description: "Include example service in firmware"
    default: false
    
  - variable: "include_version_service"
    name: "Include Version Query Service"
    type: "boolean"
    description: "Include service for querying firmware version"
    default: true
    
  - variable: "auto_upload_default"
    name: "Auto-Upload Default"
    type: "boolean"
    description: "Enable automatic firmware upload by default (NOT recommended for development)"
    default: false
    
  - variable: "include_multi_instance"
    name: "Multi-Instance Support"
    type: "boolean"
    description: "Include support for multiple microcontroller instances"
    default: false
    
  - variable: "include_diagnostics"
    name: "Include Diagnostics"
    type: "boolean"
    description: "Include diagnostic publishers for monitoring health"
    default: true
    
  - variable: "include_lifecycle"
    name: "Use Lifecycle Node"
    type: "boolean"
    description: "Use lifecycle node for host package (always recommended)"
    default: true
    
  - variable: "support_humble"
    name: "Support ROS 2 Humble"
    type: "boolean"
    description: "Include compatibility support for ROS 2 Humble (uses legacy CMake patterns)"
    default: true

file_mapping: []
