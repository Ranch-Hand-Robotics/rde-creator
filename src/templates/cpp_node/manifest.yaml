name: "C++ ROS 2 Node"
version: 0.0.0
description: A template for creating C++-based ROS 2 composable nodes with optional lifecycle support
license: "MIT"
icon: "⚡"
short_description: "High performance, real-time"
ai_directive: |
  This is a ROS 2 C++ composable node template. When generating code for this template:

  HIGH PRIORITY REQUIREMENTS:
  - Create a complete, functional ROS 2 C++ composable node using rclcpp_components
  - Follow ROS 2 C++ best practices and modern C++ standards (C++17+)
  - Include proper node lifecycle management and component registration
  - Use appropriate ROS 2 message types and interfaces
  - Implement proper error handling and logging with RCLCPP macros
  - Include comprehensive Doxygen-style documentation comments
  - Follow ROS 2 naming conventions for nodes, topics, services, and parameters
  - If you are confused about any requirements, ask for clarification
  - Do not generate placeholder code; either implement the requirement or comments explaining why it is not implemented and inform the user.


  C++ SPECIFIC GUIDELINES:
  - Use modern C++17 features (auto, smart pointers, lambdas)
  - Implement RAII principles for resource management
  - Use const correctness and noexcept where appropriate
  - Include proper header guards and include ordering
  - Use std::chrono for timing instead of deprecated methods
  - Implement thread-safe operations where needed
  - Use ROS 2 quality of service (QoS) profiles appropriately

  COMPOSABLE NODE PATTERNS:
  - Register the node as a component using RCLCPP_COMPONENTS_REGISTER_NODE
  - Include proper pluginlib export macros
  - Support loading via component manager
  - Include parameter declaration and validation
  - Implement proper cleanup in destructors

  LIFECYCLE NODE PATTERNS (when enabled):
  - Inherit from rclcpp_lifecycle::LifecycleNode instead of rclcpp::Node
  - Implement all lifecycle state callbacks (configure, activate, deactivate, cleanup, shutdown)
  - Handle state transitions properly
  - Use lifecycle publishers and subscriptions
  - Include proper error handling for state transitions

  CMAKE AND BUILD REQUIREMENTS:
  - When support_humble is enabled: Runtime detection of ROS_DISTRO environment variable
  - Automatically uses ament_target_dependencies for Humble/Galactic/Foxy
  - Automatically uses target_link_libraries for Iron/Jazzy/Kilted and later
  - When support_humble is disabled: Always uses modern target_link_libraries approach
  - Modern approach: target_link_libraries(target PUBLIC rclcpp::rclcpp ${std_msgs_TARGETS})
  - Legacy approach: ament_target_dependencies(target rclcpp std_msgs)
  - Include proper status messages to show which approach is being used

  QUALITY ASSURANCE:
  - Include proper includes and dependencies in CMakeLists.txt
  - Add input validation for parameters and messages
  - Include example usage in documentation
  - Ensure thread safety for multi-threaded operations
  - Add proper error handling and logging

  Code Layout:
  In the following specification, replace package_name with the actual package name
  and node_name with the actual node name provided by the user.
  and publisher_name or subscriber_name with the actual publisher or subscriber name provided by the user if applicable.
  and service_name with the actual service name provided by the user if applicable.
  and action_name with the actual action name provided by the user if applicable.
  The CONTRIBUTING.md should include instructions on how to build and run the node, how to run any included tests.
  Create Agents.md with instructions for AI on how to use the node with ROS 2 command line tools (ros2 topic pub, ros2 topic echo, ros2 service call, etc.).
  Ensure that you suport Windows, Linux and MacOS where possible.
  Windows requires Symbol Visiblity on exports, so ensure that is included in the CMakeLists.txt and code where applicable.
  All classes should be exported with the appropriate visibility macros.
  README.md should include comprehensive Enduser documentation about the node, its features, how to install it and run it, and example usage.

  ```
  package_name/
  ├── package.xml
  ├── CMakeLists.txt
  ├── README.md
  ├── LICENSE
  ├── CONTRIBUTING.md
  ├── Agents.md
  ├── .gitignore
  ├── include/
  │   └── package_name/
  │       ├── package_name.hpp          # Main node header
  │       └── package_name_visibility_control.h  # Visibility control for Windows
  ├── src/
  │   ├── package_name.cpp              # Main node implementation
  │   ├── package_name_publisher_name.cpp    # Publisher implementation if required
  │   ├── package_name_subscriber_name.cpp   # Subscriber implementation if required
  │   ├── package_name_service_name.cpp      # Service server implementation if required
  │   ├── package_name_client_name.cpp       # Service client implementation if required
  │   └── package_name_component.cpp         # Component registration
  ├── launch/
  │   └── package_name_node.launch.py   # Launch file for debugging
  ├── resource/
  │   └── package_name                  # Resource file for ament index
  └── test/
    └── test_package_name.cpp         # Unit tests if specified
  ```

  Visibility Control Header (for Windows compatibility):
  Create a header file named package_name_visibility_control.h in the include/package_name/ directory with the following content, where MY_LIB is replaced with the actual package name in uppercase with underscores:
  ```cpp
  #ifndef MY_LIB__VISIBILITY_CONTROL_H_
  #define MY_LIB__VISIBILITY_CONTROL_H_
  #if defined _WIN32 || defined __CYGWIN__
  #ifdef __GNUC__
    #define MY_LIB_EXPORT __attribute__ ((dllexport))
    #define MY_LIB_IMPORT __attribute__ ((dllimport))
  #else
    #define MY_LIB_EXPORT __declspec(dllexport)
    #define MY_LIB_IMPORT __declspec(dllimport)
  #endif
  #ifdef MY_LIB_BUILDING_LIBRARY
    #define MY_LIB_PUBLIC MY_LIB_EXPORT
  #else
    #define MY_LIB_PUBLIC MY_LIB_IMPORT
  #endif
  #define MY_LIB_PUBLIC_TYPE MY_LIB_PUBLIC
  #define MY_LIB_LOCAL
  #else
  // Linux visibility settings
  #define MY_LIB_PUBLIC_TYPE
  #endif
  #endif  // MY_LIB__VISIBILITY_CONTROL_H_
  ```



  CMakeLists.txt Requirements:
  Note that CMakeLists.txt must runtime support detection of ROS_DISTRO environment variable when support_humble is enabled.
  Here is a sample CMakeLists.txt that meets the requirements, adapt to the user requirements

  ``` CMakeLists.txt
    cmake_minimum_required(VERSION 3.8)
    project({{package_name}})

    if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
      add_compile_options(-Wall -Wextra -Wpedantic)
    endif()

    # find dependencies
    find_package(ament_cmake REQUIRED)
    find_package(ament_cmake_auto REQUIRED)
    ament_auto_find_build_dependencies()

    # Create ament index resource which references the libraries in the binary dir
    set(node_plugins "")

    # Include directories
    include_directories(include)

    # Create the composable node library
    add_library({{node_name}}_component SHARED
      src/node.cpp
    )

    # Set target properties
    set_target_properties({{node_name}}_component PROPERTIES
      VERSION {{package_version}}
      SOVERSION 0
    )
    target_compile_definitions(${PROJECT_NAME} PRIVATE "MY_LIB_BUILDING_LIBRARY")
    set_target_properties(${LIB_NAME} PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE)

    # Link dependencies
    set(ROS_DISTRO $ENV{ROS_DISTRO})
    if(ROS_DISTRO STREQUAL "humble" OR ROS_DISTRO STREQUAL "galactic" OR ROS_DISTRO STREQUAL "foxy")
      message(STATUS "Using legacy ament_target_dependencies for ROS 2 ${ROS_DISTRO}")
      ament_target_dependencies({{node_name}}_component
        rclcpp
        rclcpp_components
        std_msgs
        rclcpp_lifecycle
        std_srvs
      )
    else()
      message(STATUS "Using modern target_link_libraries for ROS 2 ${ROS_DISTRO}")
      target_link_libraries({{node_name}}_component PUBLIC
        ${{std_msgs_TARGETS}}
        rclcpp::rclcpp
        rclcpp_components::component
        rclcpp_components::component_manager
        {{#if include_lifecycle}}
        ${{rclcpp_lifecycle_TARGETS}}
        {{/if}}
        {{#if include_service}}
        ${{std_srvs_TARGETS}}
        {{/if}}
      )
    endif()

    # Register the component
    rclcpp_components_register_nodes({{node_name}}_component "{{package_name}}::{{node_name|pascalcase}}")

    # Install the library
    install(TARGETS
      {{node_name}}_component
      ARCHIVE DESTINATION lib
      LIBRARY DESTINATION lib
      RUNTIME DESTINATION bin
    )

    # Install include files
    install(DIRECTORY include/
      DESTINATION include
    )

    # Install launch files
    install(DIRECTORY
      launch
      DESTINATION share/${PROJECT_NAME}
    )

    if(BUILD_TESTING)
      find_package(ament_lint_auto REQUIRED)
      find_package(ament_cmake_gtest REQUIRED)
      
      # the following line skips the linter which checks for copyrights
      # comment the line when a copyright and license is added to all source files
      set(ament_cmake_copyright_FOUND TRUE)
      # the following line skips cpplint (only works in a git repo)
      # comment the line when this package is in a git repo and when
      # a copyright and license is added to all source files
      set(ament_cmake_cpplint_FOUND TRUE)
      ament_lint_auto_find_test_dependencies()

      # Add unit tests
      ament_add_gtest(test_{{package_name}}_node
        test/test_{{package_name}}_node.cpp
      )
      
      if(TARGET test_{{package_name}}_node)
        # Runtime check for ROS distribution to choose appropriate CMake approach for tests
        if(ROS_DISTRO STREQUAL "humble" OR ROS_DISTRO STREQUAL "galactic" OR ROS_DISTRO STREQUAL "foxy")
          target_link_libraries(test_{{package_name}}_node {{node_name}}_component)
          # Legacy approach for ROS 2 Humble and earlier
          ament_target_dependencies(test_{{package_name}}_node
            rclcpp
            std_msgs
            {{#if include_service}}
            std_srvs
            {{/if}}
          )
        else()
          # Modern CMake approach for ROS 2 Iron, Jazzy, Kilted and later
        # Modern CMake approach (support_humble disabled)
          target_link_libraries(test_{{package_name}}_node
            ${{std_msgs_TARGETS}}
            rclcpp::rclcpp
            rclcpp_components::component
            rclcpp_components::component_manager
            {{#if include_service}}
            ${{std_srvs_TARGETS}}
            {{/if}}
          )
        endif()
      endif()
    endif()

    ament_package()
    ```  