name: "C++ ROS 2 Node"
version: 0.0.0
description: A template for creating C++-based ROS 2 composable nodes with optional lifecycle support
license: "MIT"
icon: "⚡"
short_description: "High performance, real-time"
user_instruction: "Describe the functionality of your C++ ROS 2 composable node. Include details about topics, services, actions, lifecycle states (if applicable), hardware interfaces, performance requirements, and threading needs. Be specific about message types, QoS profiles, and real-time constraints."
example_prompt: "Create a composable lifecycle node for a laser-based object detection system. Subscribe to LaserScan messages, process them to detect objects using clustering, and publish detected objects as MarkerArray. Include lifecycle states for configuring parameters and activating/deactivating processing. Use multi-threading for parallel processing and include ros2_control hardware interface for scanner control."
test_instruction: "Describe what aspects of your C++ node should be tested. Include unit tests, integration tests, performance benchmarks, thread safety tests, and lifecycle state transitions. Tests will only be generated if you provide this description."
test_example_prompt: "Create unit tests for object clustering algorithm, integration tests for lifecycle state transitions, verify thread-safe operation with concurrent callbacks, test LaserScan processing with various input patterns, and benchmark processing latency to ensure real-time performance."
ai_directive: |
  This is a ROS 2 C++ composable node template. When generating code for this template:

  HIGH PRIORITY REQUIREMENTS:
  - Create a complete, functional ROS 2 C++ composable node using rclcpp_components
  - Follow ROS 2 C++ best practices and modern C++ standards (C++17+)
  - Include proper node lifecycle management and component registration
  - Use appropriate ROS 2 message types and interfaces
  - Implement proper error handling and logging with RCLCPP macros
  - Include comprehensive Doxygen-style documentation comments
  - Follow ROS 2 naming conventions for nodes, topics, services, and parameters
  - If you are confused about any requirements, ask for clarification
  - Do not generate placeholder code; either implement the requirement or comments explaining why it is not implemented and inform the user.


  C++ SPECIFIC GUIDELINES:
  - Use modern C++17 features (auto, smart pointers, lambdas)
  - Implement RAII principles for resource management
  - Use const correctness and noexcept where appropriate
  - Include proper header guards and include ordering
  - Use std::chrono for timing instead of deprecated methods
  - Implement thread-safe operations where needed
  - Use ROS 2 quality of service (QoS) profiles appropriately

  COMPOSABLE NODE PATTERNS:
  - Register the node as a component using RCLCPP_COMPONENTS_REGISTER_NODE
  - Include proper pluginlib export macros
  - Support loading via component manager
  - Include parameter declaration and validation
  - Implement proper cleanup in destructors

  LIFECYCLE NODE PATTERNS (when enabled):
  - Inherit from rclcpp_lifecycle::LifecycleNode instead of rclcpp::Node
  - Implement all lifecycle state callbacks (configure, activate, deactivate, cleanup, shutdown)
  - Handle state transitions properly
  - Use lifecycle publishers and subscriptions
  - Include proper error handling for state transitions

  ROS2_CONTROL PATTERNS (when user requests motor control, hardware interface, or controller functionality):
  - Determine if implementing a hardware interface (SystemInterface, ActuatorInterface, SensorInterface) or a controller node
  - For hardware interfaces: Inherit from hardware_interface::SystemInterface (or ActuatorInterface/SensorInterface)
  - For hardware interfaces: Implement on_init, on_configure, on_activate, on_deactivate, on_cleanup, on_shutdown, on_error
  - For hardware interfaces: Implement export_state_interfaces and export_command_interfaces
  - For hardware interfaces: Implement read(time, period) and write(time, period) methods
  - For hardware interfaces: Use hardware_interface::return_type for return values
  - For hardware interfaces: Register as pluginlib plugin with proper export macro
  - For controller nodes: Use controller_interface::ControllerInterface as base class
  - For controller nodes: Implement update() method for control loop logic
  - For controller nodes: Use realtime_tools for thread-safe communication
  - Include proper parameter handling for hardware configurations (CAN bus, GPIO pins, PWM settings, etc.)
  - Follow ros2_control naming conventions for joints, sensors, and command interfaces
  - Implement thread-safe hardware access with proper locking mechanisms
  - Include example YAML configuration files for controller_manager
  - Add dependencies: controller_interface, hardware_interface, pluginlib, realtime_tools
  - Use appropriate state and command interface types (position, velocity, effort, etc.)
  - Implement proper error handling and recovery for hardware communication failures
  - Include comprehensive documentation on hardware setup and configuration

  MOVEIT2 PATTERNS (when user requests motion planning, manipulation, or MoveIt2 functionality):
  - Use moveit::planning_interface::MoveGroupInterface for motion planning
  - Create planning scenes for collision checking and environment representation
  - Implement pick and place operations using moveit::planning_interface::PlanningSceneInterface
  - Use moveit_visual_tools for visualization in RViz
  - Implement trajectory execution with proper error handling and replanning
  - Support multiple planning groups (arm, gripper, whole body, etc.)
  - Include cartesian path planning for end-effector motions
  - Implement collision object management and scene updates
  - Use moveit_msgs for action/service interfaces (MoveGroup, ExecuteTrajectory, etc.)
  - Support custom constraints (orientation, position, joint constraints)
  - Include inverse kinematics solving with IKFast or KDL
  - Implement grasp planning and manipulation primitives
  - Add dependencies: moveit_ros_planning_interface, moveit_visual_tools, moveit_msgs, geometric_shapes
  - Include example SRDF and MoveIt config files
  - Support multi-arm coordination when applicable
  - Implement proper timeout and error recovery for planning failures

  NAV2 PATTERNS (when user requests navigation, path planning, or Nav2 functionality):
  - Use nav2 action clients for navigation goals (NavigateToPose, FollowPath, etc.)
  - Implement behavior tree nodes for custom navigation behaviors
  - Create costmap plugins for custom obstacle detection or path modification
  - Use nav2_msgs for navigation interfaces and status feedback
  - Implement waypoint following with nav2_waypoint_follower
  - Support dynamic reconfiguration of navigation parameters
  - Include recovery behaviors (backup, spin, wait)
  - Implement goal preemption and cancellation handling
  - Use tf2 for coordinate frame transformations
  - Include sensor data publishers (laser scans, point clouds, odometry)
  - Support localization interfaces (AMCL, particle filter updates)
  - Implement path smoothing and trajectory optimization
  - Add dependencies: nav2_msgs, nav2_core, nav2_costmap_2d, nav2_util, nav2_behavior_tree
  - Include example navigation parameter YAML files
  - Support multi-robot navigation coordination when applicable
  - Implement proper QoS settings for sensor data (best effort, transient local, etc.)

  MAVLINK PATTERNS (when user requests drone control, PX4/ArduPilot integration, or MAVLink functionality):
  - Use MAVSDK C++ library for MAVLink communication
  - Implement offboard control mode for position/velocity/attitude commands
  - Support mission upload and execution via MAVLink mission protocol
  - Include telemetry subscribers (position, attitude, battery, GPS, etc.)
  - Implement RC override and manual control passthrough
  - Use mavros for ROS 2 to MAVLink bridge when appropriate
  - Support multiple MAVLink systems (multi-vehicle coordination)
  - Implement proper heartbeat and connection monitoring
  - Include parameter get/set via MAVLink parameter protocol
  - Support camera trigger and gimbal control commands
  - Implement geofence and rally point management
  - Include flight mode switching (GUIDED, AUTO, STABILIZE, etc.)
  - Add dependencies: mavros, mavros_msgs, geographic_msgs, sensor_msgs
  - Support both serial and UDP MAVLink connections
  - Include example launch files for different vehicle types (copter, plane, rover)
  - Implement proper coordinate frame transformations (ENU, NED, ECEF)
  - Support ADSB and traffic awareness integration
  - Include safety checks and failsafe monitoring

  CMAKE AND BUILD REQUIREMENTS:
  - When support_humble is enabled: Runtime detection of ROS_DISTRO environment variable
  - Automatically uses ament_target_dependencies for Humble/Galactic/Foxy
  - Automatically uses target_link_libraries for Iron/Jazzy/Kilted and later
  - When support_humble is disabled: Always uses modern target_link_libraries approach
  - Modern approach: target_link_libraries(target PUBLIC rclcpp::rclcpp ${std_msgs_TARGETS})
  - Legacy approach: ament_target_dependencies(target rclcpp std_msgs)
  - Include proper status messages to show which approach is being used

  QUALITY ASSURANCE:
  - Include proper includes and dependencies in CMakeLists.txt
  - Add input validation for parameters and messages
  - Include example usage in documentation
  - Ensure thread safety for multi-threaded operations
  - Add proper error handling and logging

  Code Layout:
  In the following specification, replace package_name with the actual package name
  and node_name with the actual node name provided by the user.
  and publisher_name or subscriber_name with the actual publisher or subscriber name provided by the user if applicable.
  and service_name with the actual service name provided by the user if applicable.
  and action_name with the actual action name provided by the user if applicable.
  The CONTRIBUTING.md should include instructions on how to build and run the node, how to run any included tests.
  Create Agents.md with instructions for AI on how to use the node with ROS 2 command line tools (ros2 topic pub, ros2 topic echo, ros2 service call, etc.).
  Ensure that you suport Windows, Linux and MacOS where possible.
  Windows requires Symbol Visiblity on exports, so ensure that is included in the CMakeLists.txt and code where applicable.
  All classes should be exported with the appropriate visibility macros.
  README.md should include comprehensive Enduser documentation about the node, its features, how to install it and run it, and example usage.

  ```
  package_name/
  ├── package.xml
  ├── CMakeLists.txt
  ├── README.md
  ├── LICENSE
  ├── CONTRIBUTING.md
  ├── Agents.md
  ├── .gitignore
  ├── include/
  │   └── package_name/
  │       ├── package_name.hpp          # Main node header
  │       ├── package_name_visibility_control.h  # Visibility control for Windows
  │       ├── package_name_hardware_interface.hpp  # Hardware interface header (ros2_control only)
  │       ├── package_name_controller.hpp          # Controller header (ros2_control only)
  │       ├── package_name_move_group.hpp          # MoveIt2 interface header (moveit2 only)
  │       ├── package_name_navigator.hpp           # Nav2 interface header (nav2 only)
  │       └── package_name_mavlink.hpp             # MAVLink interface header (mavlink only)
  ├── src/
  │   ├── package_name.cpp              # Main node implementation
  │   ├── package_name_publisher_name.cpp    # Publisher implementation if required
  │   ├── package_name_subscriber_name.cpp   # Subscriber implementation if required
  │   ├── package_name_service_name.cpp      # Service server implementation if required
  │   ├── package_name_client_name.cpp       # Service client implementation if required
  │   ├── package_name_component.cpp         # Component registration
  │   ├── package_name_hardware_interface.cpp  # Hardware interface implementation (ros2_control only)
  │   ├── package_name_controller.cpp          # Controller implementation (ros2_control only)
  │   ├── package_name_move_group.cpp          # MoveIt2 implementation (moveit2 only)
  │   ├── package_name_navigator.cpp           # Nav2 implementation (nav2 only)
  │   └── package_name_mavlink.cpp             # MAVLink implementation (mavlink only)
  ├── config/
  │   ├── controllers.yaml              # Controller configuration (ros2_control only)
  │   ├── hardware.yaml                 # Hardware interface configuration (ros2_control only)
  │   ├── moveit_config/                # MoveIt2 configuration directory (moveit2 only)
  │   │   ├── config/
  │   │   │   ├── joint_limits.yaml
  │   │   │   ├── kinematics.yaml
  │   │   │   └── ompl_planning.yaml
  │   │   └── package_name.srdf         # Semantic robot description
  │   ├── nav2_params.yaml              # Nav2 navigation parameters (nav2 only)
  │   └── mavlink_config.yaml           # MAVLink connection configuration (mavlink only)
  ├── launch/
  │   ├── package_name_node.launch.py   # Launch file for debugging
  │   ├── package_name_control.launch.py  # Control system launch file (ros2_control only)
  │   ├── package_name_moveit.launch.py   # MoveIt2 launch file (moveit2 only)
  │   ├── package_name_navigation.launch.py  # Nav2 launch file (nav2 only)
  │   └── package_name_mavlink.launch.py    # MAVLink launch file (mavlink only)
  ├── resource/
  │   └── package_name                  # Resource file for ament index
  └── test/
    ├── test_package_name.cpp         # Unit tests if specified
    ├── test_hardware_interface.cpp   # Hardware interface tests (ros2_control only)
    ├── test_controller.cpp           # Controller tests (ros2_control only)
    ├── test_move_group.cpp           # MoveIt2 tests (moveit2 only)
    ├── test_navigator.cpp            # Nav2 tests (nav2 only)
    └── test_mavlink.cpp              # MAVLink tests (mavlink only)
  ```

  Visibility Control Header (for Windows compatibility):
  Create a header file named package_name_visibility_control.h in the include/package_name/ directory with the following content, where MY_LIB is replaced with the actual package name in uppercase with underscores:
  ```cpp
  #ifndef MY_LIB__VISIBILITY_CONTROL_H_
  #define MY_LIB__VISIBILITY_CONTROL_H_
  #if defined _WIN32 || defined __CYGWIN__
  #ifdef __GNUC__
    #define MY_LIB_EXPORT __attribute__ ((dllexport))
    #define MY_LIB_IMPORT __attribute__ ((dllimport))
  #else
    #define MY_LIB_EXPORT __declspec(dllexport)
    #define MY_LIB_IMPORT __declspec(dllimport)
  #endif
  #ifdef MY_LIB_BUILDING_LIBRARY
    #define MY_LIB_PUBLIC MY_LIB_EXPORT
  #else
    #define MY_LIB_PUBLIC MY_LIB_IMPORT
  #endif
  #define MY_LIB_PUBLIC_TYPE MY_LIB_PUBLIC
  #define MY_LIB_LOCAL
  #else
  // Linux visibility settings
  #define MY_LIB_EXPORT __attribute__ ((visibility("default")))
  #define MY_LIB_IMPORT __attribute__ ((visibility("default")))
  #ifdef MY_LIB_BUILDING_LIBRARY
    #define MY_LIB_PUBLIC MY_LIB_EXPORT
  #else
    #define MY_LIB_PUBLIC MY_LIB_IMPORT
  #endif
  #define MY_LIB_PUBLIC_TYPE MY_LIB_IMPORT
  #define MY_LIB_LOCAL __attribute__ ((visibility("hidden")))
  #endif
  #endif  // MY_LIB__VISIBILITY_CONTROL_H_
  ```



  CMakeLists.txt Requirements:
  Note that CMakeLists.txt must runtime support detection of ROS_DISTRO environment variable when support_humble is enabled.
  Here is a sample CMakeLists.txt that meets the requirements, adapt to the user requirements

  ``` CMakeLists.txt
    cmake_minimum_required(VERSION 3.8)
    project({{package_name}})

    if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
      add_compile_options(-Wall -Wextra -Wpedantic)
    endif()

    # find dependencies
    find_package(ament_cmake REQUIRED)
    find_package(ament_cmake_auto REQUIRED)
    ament_auto_find_build_dependencies()

    # Create ament index resource which references the libraries in the binary dir
    set(node_plugins "")

    # Include directories
    include_directories(include)

    # Create the composable node library
    add_library({{node_name}}_component SHARED
      src/node.cpp
    )

    # Set target properties
    set_target_properties({{node_name}}_component PROPERTIES
      VERSION {{package_version}}
      SOVERSION 0
    )
    target_compile_definitions({{node_name}}_component PRIVATE "MY_LIB_BUILDING_LIBRARY")
    set_target_properties(${LIB_NAME} PROPERTIES WINDOWS_EXPORT_ALL_SYMBOLS TRUE)

    # Link dependencies
    set(ROS_DISTRO $ENV{ROS_DISTRO})
    if(ROS_DISTRO STREQUAL "humble" OR ROS_DISTRO STREQUAL "galactic" OR ROS_DISTRO STREQUAL "foxy")
      message(STATUS "Using legacy ament_target_dependencies for ROS 2 ${ROS_DISTRO}")
      ament_target_dependencies({{node_name}}_component
        rclcpp
        rclcpp_components
        std_msgs
        rclcpp_lifecycle
        std_srvs
        {{#if include_ros2_control}}
        controller_interface
        hardware_interface
        pluginlib
        realtime_tools
        {{/if}}
        {{#if include_moveit2}}
        moveit_ros_planning_interface
        moveit_visual_tools
        moveit_msgs
        geometric_shapes
        {{/if}}
        {{#if include_nav2}}
        nav2_msgs
        nav2_core
        nav2_costmap_2d
        nav2_util
        nav2_behavior_tree
        tf2
        tf2_ros
        {{/if}}
        {{#if include_mavlink}}
        mavros
        mavros_msgs
        geographic_msgs
        sensor_msgs
        {{/if}}
      )
    else()
      message(STATUS "Using modern target_link_libraries for ROS 2 ${ROS_DISTRO}")
      target_link_libraries({{node_name}}_component PUBLIC
        ${{std_msgs_TARGETS}}
        rclcpp::rclcpp
        rclcpp_components::component
        rclcpp_components::component_manager
        {{#if include_lifecycle}}
        ${{rclcpp_lifecycle_TARGETS}}
        {{/if}}
        {{#if include_service}}
        ${{std_srvs_TARGETS}}
        {{/if}}
        {{#if include_ros2_control}}
        controller_interface::controller_interface
        hardware_interface::hardware_interface
        pluginlib::pluginlib
        realtime_tools::realtime_tools
        {{/if}}
        {{#if include_moveit2}}
        moveit_ros_planning_interface::moveit_ros_planning_interface
        moveit_visual_tools::moveit_visual_tools
        ${{moveit_msgs_TARGETS}}
        ${{geometric_shapes_TARGETS}}
        {{/if}}
        {{#if include_nav2}}
        ${{nav2_msgs_TARGETS}}
        nav2_core::nav2_core
        nav2_costmap_2d::nav2_costmap_2d_client
        nav2_util::nav2_util_core
        ${{nav2_behavior_tree_TARGETS}}
        tf2::tf2
        tf2_ros::tf2_ros
        {{/if}}
        {{#if include_mavlink}}
        ${{mavros_TARGETS}}
        ${{mavros_msgs_TARGETS}}
        ${{geographic_msgs_TARGETS}}
        ${{sensor_msgs_TARGETS}}
        {{/if}}
      )
    endif()

    # Register the component
    rclcpp_components_register_nodes({{node_name}}_component "{{package_name}}::{{node_name|pascalcase}}")

    # Install the library
    install(TARGETS
      {{node_name}}_component
      ARCHIVE DESTINATION lib
      LIBRARY DESTINATION lib
      RUNTIME DESTINATION bin
    )

    # Install include files
    install(DIRECTORY include/
      DESTINATION include
    )

    # Install launch files
    install(DIRECTORY
      launch
      DESTINATION share/${PROJECT_NAME}
    )

    if(BUILD_TESTING)
      find_package(ament_lint_auto REQUIRED)
      find_package(ament_cmake_gtest REQUIRED)
      
      # the following line skips the linter which checks for copyrights
      # comment the line when a copyright and license is added to all source files
      set(ament_cmake_copyright_FOUND TRUE)
      # the following line skips cpplint (only works in a git repo)
      # comment the line when this package is in a git repo and when
      # a copyright and license is added to all source files
      set(ament_cmake_cpplint_FOUND TRUE)
      ament_lint_auto_find_test_dependencies()

      # Add unit tests
      ament_add_gtest(test_{{package_name}}_node
        test/test_{{package_name}}_node.cpp
      )
      
      if(TARGET test_{{package_name}}_node)
        # Runtime check for ROS distribution to choose appropriate CMake approach for tests
        if(ROS_DISTRO STREQUAL "humble" OR ROS_DISTRO STREQUAL "galactic" OR ROS_DISTRO STREQUAL "foxy")
          target_link_libraries(test_{{package_name}}_node {{node_name}}_component)
          # Legacy approach for ROS 2 Humble and earlier
          ament_target_dependencies(test_{{package_name}}_node
            rclcpp
            std_msgs
            {{#if include_service}}
            std_srvs
            {{/if}}
          )
        else()
          # Modern CMake approach for ROS 2 Iron, Jazzy, Kilted and later
        # Modern CMake approach (support_humble disabled)
          target_link_libraries(test_{{package_name}}_node
            {{node_name}}_component
            ${{std_msgs_TARGETS}}
            rclcpp::rclcpp
            rclcpp_components::component
            rclcpp_components::component_manager
            {{#if include_service}}
            ${{std_srvs_TARGETS}}
            {{/if}}
          )
        endif()
      endif()
    endif()

    ament_package()
    ```  