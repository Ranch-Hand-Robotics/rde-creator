name: "Python ROS 2 Node"
version: 0.0.0
description: A template for creating Python-based ROS 2 nodes with various communication patterns
license: "MIT"
icon: "ğŸ"
short_description: "Fast prototyping, rich libraries"
ai_directive: |
  This is a ROS 2 Python node template. When generating code for this template:

  HIGH PRIORITY REQUIREMENTS:
  - Create a complete, functional ROS 2 Python node using rclpy
  - Follow ROS 2 Python best practices and conventions
  - Include proper node lifecycle management (initialization, spinning, shutdown)
  - Use appropriate ROS 2 message types and interfaces
  - Implement proper error handling and logging
  - Include comprehensive docstrings and comments
  - Follow ROS 2 naming conventions for nodes, topics, services, and parameters
  - Add python tests if prompted by the user. If no tests are requested, do not include any test files.

  PYTHON-SPECIFIC GUIDELINES:
  - Use modern Python 3.12+ syntax and features
  - Implement proper async/await patterns where appropriate
  - Include type hints for better code maintainability
  - Use logging instead of print statements for debugging
  - Handle ROS 2 exceptions properly (e.g., ParameterNotDeclaredException)
  - Include proper QoS settings for reliability and durability
  - Use timer callbacks for periodic tasks
  - Implement graceful shutdown handling

  NODE ARCHITECTURE PATTERNS:
  - Publisher nodes: Include message publishing at configurable rates
  - Subscriber nodes: Include message processing with callbacks
  - Service nodes: Include both client and server implementations
  - Action nodes: Include action server/client with proper goal handling
  - Parameter nodes: Include dynamic parameter handling
  - Timer-based nodes: Include periodic task execution
  - Lifecycle nodes: Include state transitions and callbacks if required
  - Create Composable nodes when possible

  ROS2_CONTROL PATTERNS (when user requests motor control, hardware interface, or controller functionality):
  - Python primarily supports controller nodes (not hardware interfaces which require C++)
  - For controller nodes: Create a node that interfaces with ros2_control via topics and services
  - For controller nodes: Subscribe to joint state topics from hardware interfaces
  - For controller nodes: Publish command messages to command topics
  - Use dynamic_reconfigure for runtime parameter adjustments
  - Implement control algorithms (PID, trajectory following, etc.) in Python
  - Use asyncio for concurrent control operations where needed
  - Include parameter validation for control gains and limits
  - Implement safety checks and bounds checking for commands
  - Add comprehensive logging for control loop performance
  - Include example configuration files for controller parameters
  - Create visualization tools for debugging control performance
  - Note: For hardware interface implementation, recommend C++ template instead
  - Support reading from and writing to ros2_control topics/services
  - Include proper QoS settings for real-time control communication

  MOVEIT2 PATTERNS (when user requests motion planning, manipulation, or MoveIt2 functionality):
  - Use moveit_py or pymoveit2 for Python MoveIt2 interface
  - Create motion planning requests using MoveGroupInterface
  - Implement pick and place sequences with planning scene management
  - Use geometry_msgs for pose targets and trajectory generation
  - Include collision object management for scene updates
  - Support cartesian path planning with waypoint following
  - Implement grasp generation and manipulation primitives
  - Use moveit_msgs action clients (MoveGroup, ExecuteTrajectory)
  - Include inverse kinematics solving with configurable solvers
  - Support multiple planning groups and end effectors
  - Implement custom constraints (orientation, position, visibility)
  - Add comprehensive error handling for planning failures
  - Include visualization utilities for RViz debugging
  - Use asyncio for non-blocking motion execution
  - Support trajectory scaling and timing adjustments

  NAV2 PATTERNS (when user requests navigation, path planning, or Nav2 functionality):
  - Use nav2_simple_commander for Python navigation interface
  - Implement NavigateToPose and NavigateThroughPoses actions
  - Create custom behavior tree nodes in Python
  - Support waypoint following with nav2_waypoint_follower
  - Implement goal preemption and recovery behaviors
  - Use action clients for navigation feedback and status
  - Include costmap monitoring and obstacle detection
  - Support dynamic parameter reconfiguration
  - Implement pose estimation updates and localization
  - Use tf2_py for coordinate transformations
  - Include sensor data processing (laser scans, odometry)
  - Support multi-robot coordination when applicable
  - Add path smoothing and trajectory optimization
  - Implement geofence checking and safety boundaries
  - Include comprehensive logging for navigation events

  MAVLINK PATTERNS (when user requests drone control, PX4/ArduPilot integration, or MAVLink functionality):
  - Use pymavlink library for MAVLink protocol communication
  - Implement offboard control for position/velocity commands
  - Use mavros for ROS 2 to MAVLink bridge
  - Subscribe to telemetry topics (pose, velocity, battery, GPS)
  - Implement mission upload via mavros mission services
  - Support flight mode changes (GUIDED, AUTO, etc.)
  - Include RC override and manual control
  - Implement arming/disarming sequences with safety checks
  - Use asyncio for concurrent MAVLink communication
  - Support multiple vehicle coordination
  - Include parameter get/set via mavros services
  - Implement geofence and rally point management
  - Add camera trigger and gimbal control
  - Support ADSB traffic awareness
  - Include coordinate frame transformations (ENU, NED)
  - Implement heartbeat monitoring and connection management
  - Add comprehensive safety checks and failsafes

  QUALITY ASSURANCE:
  - Include proper imports and dependencies
  - Add input validation for parameters and messages
  - Include example usage in docstrings
  - Ensure thread safety for multi-threaded operations
  - Add proper cleanup in destructors

  Code structure should follow this layout:
  replaced with actual package name and node name where applicable.

  ```
  package_name/
  â”œâ”€â”€ package.xml
  â”œâ”€â”€ setup.py
  â”œâ”€â”€ setup.cfg
  â”œâ”€â”€ resource/package_name
  â”œâ”€â”€ test/
  â”‚   â””â”€â”€ test_package_name.py  # Unit tests if specified; otherwise do not include.
  â”œâ”€â”€ README.md
  â”œâ”€â”€ LICENSE
  â”œâ”€â”€ CONTRIBUTING.md
  â”œâ”€â”€ Agents.md
  â”œâ”€â”€ .gitignore
  â”œâ”€â”€ config/
  â”‚   â”œâ”€â”€ controller_params.yaml  # Controller parameters (ros2_control only)
  â”‚   â”œâ”€â”€ moveit_config/          # MoveIt2 configuration (moveit2 only)
  â”‚   â”‚   â”œâ”€â”€ joint_limits.yaml
  â”‚   â”‚   â”œâ”€â”€ kinematics.yaml
  â”‚   â”‚   â””â”€â”€ ompl_planning.yaml
  â”‚   â”œâ”€â”€ nav2_params.yaml        # Nav2 navigation parameters (nav2 only)
  â”‚   â””â”€â”€ mavlink_config.yaml     # MAVLink configuration (mavlink only)
  â”œâ”€â”€ launch/
  â”‚   â”œâ”€â”€ node.launch.py  # One launch simple file for each node to facilitate debugging. If multiple nodes are included, create a launch file which calls each node's launch file.
  â”‚   â”œâ”€â”€ control.launch.py  # Controller launch file (ros2_control only)
  â”‚   â”œâ”€â”€ moveit.launch.py   # MoveIt2 launch file (moveit2 only)
  â”‚   â”œâ”€â”€ navigation.launch.py  # Nav2 launch file (nav2 only)
  â”‚   â””â”€â”€ mavlink.launch.py     # MAVLink launch file (mavlink only)
  â””â”€â”€ package_name/
      â”œâ”€â”€ __init.py
      â”œâ”€â”€ node.py # If a simple implementation, name node.py for the name of the package. If the node has multiple publishers, subscribers, services, actions, etc., create a file for each and name the node file based on its primary function.
      â”œâ”€â”€ controller.py  # Controller implementation (ros2_control only)
      â”œâ”€â”€ move_group.py  # MoveIt2 implementation (moveit2 only)
      â”œâ”€â”€ navigator.py   # Nav2 implementation (nav2 only)
      â””â”€â”€ mavlink_interface.py  # MAVLink implementation (mavlink only)
  ```

  Setup.cfg must include:
  ```ini
    [develop]
    script_dir=$base/lib/package_name
    [install]
    install_scripts=$base/lib/package_name
  ```