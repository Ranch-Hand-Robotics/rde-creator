name: "Python ROS 2 Node"
version: 0.0.0
description: A template for creating Python-based ROS 2 nodes with various communication patterns
license: "MIT"
icon: "ğŸ"
short_description: "Fast prototyping, rich libraries"
ai_directive: |
  This is a ROS 2 Python node template. When generating code for this template:

  HIGH PRIORITY REQUIREMENTS:
  - Create a complete, functional ROS 2 Python node using rclpy
  - Follow ROS 2 Python best practices and conventions
  - Include proper node lifecycle management (initialization, spinning, shutdown)
  - Use appropriate ROS 2 message types and interfaces
  - Implement proper error handling and logging
  - Include comprehensive docstrings and comments
  - Follow ROS 2 naming conventions for nodes, topics, services, and parameters
  - Add python tests if prompted by the user. If no tests are requested, do not include any test files.

  PYTHON-SPECIFIC GUIDELINES:
  - Use modern Python 3.12+ syntax and features
  - Implement proper async/await patterns where appropriate
  - Include type hints for better code maintainability
  - Use logging instead of print statements for debugging
  - Handle ROS 2 exceptions properly (e.g., ParameterNotDeclaredException)
  - Include proper QoS settings for reliability and durability
  - Use timer callbacks for periodic tasks
  - Implement graceful shutdown handling

  NODE ARCHITECTURE PATTERNS:
  - Publisher nodes: Include message publishing at configurable rates
  - Subscriber nodes: Include message processing with callbacks
  - Service nodes: Include both client and server implementations
  - Action nodes: Include action server/client with proper goal handling
  - Parameter nodes: Include dynamic parameter handling
  - Timer-based nodes: Include periodic task execution
  - Lifecycle nodes: Include state transitions and callbacks if required
  - Create Composable nodes when possible

  QUALITY ASSURANCE:
  - Include proper imports and dependencies
  - Add input validation for parameters and messages
  - Include example usage in docstrings
  - Ensure thread safety for multi-threaded operations
  - Add proper cleanup in destructors

  Code structure should follow this layout:
  replaced with actual package name and node name where applicable.

  ```
  package_name/
  â”œâ”€â”€ package.xml
  â”œâ”€â”€ setup.py
  â”œâ”€â”€ setup.cfg
  â”œâ”€â”€ resource/package_name
  â”œâ”€â”€ test/
  â”‚   â””â”€â”€ test_package_name.py  # Unit tests if specified; otherwise do not include.
  â”œâ”€â”€ README.md
  â”œâ”€â”€ LICENSE
  â”œâ”€â”€ CONTRIBUTING.md
  â”œâ”€â”€ Agents.md
  â”œâ”€â”€ .gitignore
  â”œâ”€â”€ launch/
  â”‚   â””â”€â”€ node.launch.py  # One launch simple file for each node to facilitate debugging. If multiple nodes are included, create a launch file which calls each node's launch file.
  â””â”€â”€ package_name/
      â”œâ”€â”€ __init.py
      â””â”€â”€ node.py
  ```

  Setup.cfg must include:
  ```ini
    [develop]
    script_dir=$base/lib/package_name
    [install]
    install_scripts=$base/lib/package_name
  ```